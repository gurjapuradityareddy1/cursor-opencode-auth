import {
  mkdir,
  readFile,
  readdir,
  rename,
  stat,
  unlink,
  writeFile,
} from "node:fs/promises";
import * as path from "node:path";
import { fileURLToPath } from "node:url";

const OPENCODE_PLUGIN_DISPLAY_NAME = "cursor-opencode-auth";
let cachedSelfVersion: string | undefined;

async function fileExists(filePath: string): Promise<boolean> {
  try {
    await stat(filePath);
    return true;
  } catch {
    return false;
  }
}

function getOpencodePluginsDir(): string | undefined {
  const xdg = process.env.XDG_CONFIG_HOME;
  const home = process.env.HOME;
  const configHome = xdg || (home ? path.join(home, ".config") : undefined);
  if (!configHome) return undefined;
  return path.join(configHome, "opencode", "plugins");
}

async function getSelfVersion(): Promise<string | undefined> {
  if (cachedSelfVersion) return cachedSelfVersion;
  try {
    // Works for both local dev (`src/`) and built (`dist/`) entrypoints.
    const here = path.dirname(fileURLToPath(import.meta.url));
    const pkgRoot = path.resolve(here, "..", "..");
    const pkgJsonPath = path.resolve(pkgRoot, "package.json");
    const raw = await readFile(pkgJsonPath, "utf8");
    const pkg = JSON.parse(raw) as { version?: unknown };
    const version = typeof pkg?.version === "string" ? pkg.version : undefined;
    cachedSelfVersion = version;
    return version;
  } catch {
    return undefined;
  }
}

async function getSelfEntrypointPath(): Promise<string> {
  const here = path.dirname(fileURLToPath(import.meta.url));
  const pkgRoot = path.resolve(here, "..", "..");
  const distEntry = path.join(pkgRoot, "dist", "index.js");
  if (await fileExists(distEntry)) return distEntry;
  const srcEntry = path.join(pkgRoot, "src", "index.ts");
  if (await fileExists(srcEntry)) return srcEntry;
  return fileURLToPath(import.meta.url);
}

function isReExportShimFile(text: string): boolean {
  return /export\s+\{\s*CursorPlugin\s*\}\s+from\s+["']/.test(text);
}

export async function ensurePluginShowsVersionInStatus(
  client: any,
): Promise<{ changed: boolean; targetName?: string } | undefined> {
  const version = await getSelfVersion();
  if (!version) return;

  const pluginsDir = getOpencodePluginsDir();
  if (!pluginsDir) return;

  const base = OPENCODE_PLUGIN_DISPLAY_NAME;
  const versionedStem = `${base}@${version}`;
  const versionedTs = path.join(pluginsDir, `${versionedStem}.ts`);
  const versionedJs = path.join(pluginsDir, `${versionedStem}.js`);

  // Already versioned.
  if ((await fileExists(versionedTs)) || (await fileExists(versionedJs))) return;

  await mkdir(pluginsDir, { recursive: true });

  // Prefer renaming an existing shim to avoid duplicates.
  const candidates: string[] = [
    path.join(pluginsDir, `${base}.ts`),
    path.join(pluginsDir, `${base}.js`),
  ];

  try {
    const entries = await readdir(pluginsDir);
    for (const name of entries) {
      if (!name.startsWith(`${base}@`)) continue;
      if (!(name.endsWith(".ts") || name.endsWith(".js"))) continue;
      candidates.push(path.join(pluginsDir, name));
    }
  } catch {
    // ignore
  }

  for (const cand of candidates) {
    if (!(await fileExists(cand))) continue;
    const ext = cand.endsWith(".js") ? "js" : cand.endsWith(".ts") ? "ts" : undefined;
    if (!ext) continue;

    const text = await readFile(cand, "utf8").catch(() => "");
    if (text && !isReExportShimFile(text)) continue;

    const target = path.join(pluginsDir, `${versionedStem}.${ext}`);
    if (cand === target) return;
    try {
      await rename(cand, target);
      return { changed: true, targetName: path.basename(target, path.extname(target)) };
    } catch {
      // try next candidate
    }
  }

  // No existing shim found; create a versioned shim file.
  const entryPath = await getSelfEntrypointPath();
  const shim = `// Auto-generated by ${base} v${version}\nexport { CursorPlugin } from ${JSON.stringify(entryPath)};\n`;
  await writeFile(versionedTs, shim, "utf8");

  // Best-effort: remove other versioned shims that are simple re-exports.
  try {
    const entries = await readdir(pluginsDir);
    await Promise.all(
      entries.map(async (name) => {
        if (!name.startsWith(`${base}@`)) return;
        if (name === `${versionedStem}.ts` || name === `${versionedStem}.js`) return;
        if (!(name.endsWith(".ts") || name.endsWith(".js"))) return;
        const full = path.join(pluginsDir, name);
        const text = await readFile(full, "utf8").catch(() => "");
        if (!text || !isReExportShimFile(text)) return;
        await unlink(full).catch(() => undefined);
      }),
    );
  } catch {
    // ignore
  }

  // Optional UX: toast that a restart is needed to refresh /status.
  try {
    await client?.tui?.showToast?.({
      body: {
        title: base,
        message: `Installed versioned plugin entry (${versionedStem}). Restart OpenCode to see it in /status.`,
        variant: "success",
        duration: 6_000,
      },
    });
  } catch {
    // ignore
  }

  return { changed: true, targetName: versionedStem };
}
